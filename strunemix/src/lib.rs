//! Strunemix allows to work with structs as if they were enums.
//! 
//! # Example
//! 
//! ```rust
//! use strunemix::*;
//! 
//! #[derive(Default, Strunemix)]
//! #[strunemix_derive_data(Debug, PartialEq)]
//! struct Person {
//!    pseudo: String,
//!    phone: Option<String>,
//!    age: i32,
//! }
//! 
//! let person = Person {pseudo: "John".to_string(), phone: Some("123456789".to_string()), age: 42};
//! 
//! let pseudo_name = PersonAttrName::Pseudo;
//! let phone_name = PersonAttrName::Phone;
//! let age_name = PersonAttrName::Age;
//! 
//! assert_eq!(Person::as_attr_name_array(), [pseudo_name, phone_name, age_name]);
//! assert_eq!(pseudo_name.name(), "pseudo");
//! assert_eq!(phone_name.name(), "phone");
//! assert_eq!(age_name.name(), "age");
//! 
//! let pseudo_data = PersonAttrData::Pseudo("John".to_string());
//! let phone_data = PersonAttrData::Phone(Some("123456789".to_string()));
//! let age_data = PersonAttrData::Age(42);
//! 
//! assert_eq!(person.to_attr_data_array(), [pseudo_data, phone_data, age_data]);
//! 
//! ```

/// Trait implemented automatically on structs that have been strunemixed.
pub trait StrunemixTrait<T, U, const N: usize>
where 
    T: StrunemixName + From<U>
{

    /// The number of fields in the struct.
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// struct Person {
    ///   age: i32,
    ///   name: Option<String>,
    /// }
    /// 
    /// assert_eq!(Person::FIELDS_COUNT, 2);
    ///
    const FIELDS_COUNT: usize = N;

    /// Convert a struct into an array of its attributes names, using enums of its field names.
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// struct Person {
    ///    age: i32,
    ///    name: Option<String>,
    /// }
    /// 
    /// assert_eq!(Person::as_attr_name_array(), [PersonAttrName::Age, PersonAttrName::Name]);
    /// ```
    fn as_attr_name_array() -> [T; N] {
        panic!("This function should be implemented by the derive macro")
    }

    /// Convert a struct into an array of its attributes data, using enums variants of its field names.
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// #[strunemix_derive_data(Debug, PartialEq)]
    /// struct Person {
    ///    age: i32,
    ///    name: Option<String>,
    /// }
    /// 
    /// let person = Person {age: 42, name: Some("John".to_string())};
    /// 
    /// let age = PersonAttrData::Age(42);
    /// let name = PersonAttrData::Name(Some("John".to_string()));
    ///
    /// assert_eq!(person.to_attr_data_array(), [age, name]);
    /// ```
    fn to_attr_data_array(self) -> [U; N]
    where 
        U: StrunemixData<T>,
        Self: Sized
    {panic!("This function should be implemented by the derive macro")}

    /// Convert an array of attributes data into a struct, using enums variants of its field names.
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Debug, Default, PartialEq, Strunemix)]
    /// struct Person {
    ///   pseudo: String,
    ///   phone: Option<String>,
    ///   age: i32,
    /// }
    /// 
    /// let data = [
    ///     PersonAttrData::Pseudo("John".to_string()),
    ///     PersonAttrData::Phone(Some("123456789".to_string())),
    ///     PersonAttrData::Age(42)
    /// ];
    /// 
    /// let person = Person::from_attr_data_array(data).unwrap();
    /// 
    /// let expected = Person {pseudo: "John".to_string(), phone: Some("123456789".to_string()), age: 42};
    /// 
    /// assert_eq!(person, expected);
    fn from_attr_data_array(data: [U; N]) -> Result<Self, <Self as TryFrom<[U; N]>>::Error>
    where Self: TryFrom<[U; N]> {
        TryFrom::try_from(data)
    }
}


/// Trait implemented automatically on enums names generated by strunemix.
pub trait StrunemixName
where 
    Self: Sized + std::str::FromStr
{

    /// Get the name of the enum value as a string slice
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// struct Person {
    ///    age: i32,
    ///    name: Option<String>,
    /// }
    /// 
    /// let age = PersonAttrName::Age;
    /// 
    /// assert_eq!(age.name(), "age");
    /// ```
    fn name(&self) -> &'static str {
        panic!("This function should be implemented by the derive macro")
    }

    /// Get an enum value by its name
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// struct Person {
    ///   age: i32,
    ///   name: Option<String>,
    /// }
    /// 
    /// let age = PersonAttrName::from_str("age").unwrap();
    /// 
    /// assert_eq!(age, PersonAttrName::Age);
    fn from_str(name: &str) -> Option<Self> {
        <Self as std::str::FromStr>::from_str(name).ok()
    }

}

/// Trait implemented automatically on enums data generated by strunemix.
pub trait StrunemixData<T>
where 
    Self: Sized,
    T: StrunemixName + From<Self>
{
    /// Get the name of the enum value
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// struct Person {
    ///   age: i32,
    ///   name: Option<String>
    /// }
    /// 
    /// let age = PersonAttrData::Age(42);
    /// 
    /// assert_eq!(age.name(), PersonAttrName::Age);
    fn name(self) -> T
    {
        T::from(self)
    }
}

/// Trait that must be implemented to allow the conversion from a string slice to a field.
pub trait StrunemixParsableData<'a, T>
where 
    Self: Sized,
    T: StrunemixName
{
    /// Make an enum data from a enum name and the associated data as a string slice.
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// #[strunemix_derive_data(Debug, PartialEq)]
    /// struct Person {
    ///    age: i32,
    ///    name: Option<String>,
    /// }
    /// 
    /// // Implement the trait for the struct
    /// // This allow any kind of conversion from a string to the inner type of the field
    /// impl StrunemixParsableData<'_, PersonAttrName> for PersonAttrData {
    ///   fn from_name_and_data(name: PersonAttrName, data: &str) -> Result<Self, ()> {
    ///     match name {
    ///       PersonAttrName::Name => Ok(PersonAttrData::Name(Some(data.to_string()))),
    ///       PersonAttrName::Age => data.parse().map_err(|_| ()).map(|age| PersonAttrData::Age(age))
    ///     }
    ///   }
    /// }
    /// 
    /// let age_name = PersonAttrName::Age;
    /// let age_data = "42";
    /// 
    /// let age = PersonAttrData::from_name_and_data(age_name, age_data).unwrap();
    /// 
    /// assert_eq!(PersonAttrData::Age(42), age);
    fn from_name_and_data(s: T, arg: &'a str) -> Result<Self, ()>;

    /// Make an enum data from a name as string and the associated data as a string slice.
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Default, Strunemix)]
    /// #[strunemix_derive_data(Debug, PartialEq)]
    /// struct Person {
    ///    age: i32,
    ///    name: Option<String>,
    /// }
    /// 
    /// // Implement the trait for the struct
    /// // This allow any kind of conversion from a string to the inner type of the field
    /// impl StrunemixParsableData<'_, PersonAttrName> for PersonAttrData {
    ///   fn from_name_and_data(name: PersonAttrName, data: &str) -> Result<Self, ()> {
    ///     match name {
    ///       PersonAttrName::Name => Ok(PersonAttrData::Name(Some(data.to_string()))),
    ///       PersonAttrName::Age => data.parse().map_err(|_| ()).map(|age| PersonAttrData::Age(age))
    ///     }
    ///   }
    /// }
    /// 
    /// let age_name = "age";
    /// let age_data = "42";
    /// 
    /// let age = PersonAttrData::from_str_and_data(age_name, age_data).unwrap();
    /// 
    /// assert_eq!(PersonAttrData::Age(42), age);
    fn from_str_and_data(s: &str, arg: &'a str) -> Result<Self, ()> {
        match <T as StrunemixName>::from_str(s) {
            Some(name) => Self::from_name_and_data(name, arg),
            None => Err(())
        }
    }
}

/// Implements the [`StrunemixTrait`] on a struct automatically and generate the necessary enums and traits implementations.
/// 
/// # Examples
/// 
/// ## Skip a field
/// 
/// This attribute can be used to skip a field from the generated enums and traits.
/// 
/// ```rust
/// use strunemix::*;
/// 
/// #[derive(Default, Strunemix)]
/// struct Person {
///   pseudo: String,
///   age: i32,
///   #[strunemix(skip)]
///   phone: Option<String>,
/// }
/// 
/// assert_eq!(Person::FIELDS_COUNT, 2);
/// ```
/// 
/// ## Derive Macros on the enums names
/// 
/// This attribute can be used to derive some macros on the generated enums names.
/// If the attribute is not used, the macros Debug, PartialEq, Eq, Clone and Copy are derived by default.
/// 
/// ```rust
/// use strunemix::*;
/// 
/// #[derive(Default, Strunemix)]
/// #[strunemix_derive_name(Debug, PartialEq, Eq, Clone, Copy, Hash)]
/// struct Person {
///   pseudo: String,
///   age: i32,
///   phone: Option<String>,
/// }
/// ```
/// 
/// ## Derive Macros on the enums data
/// 
/// This attribute can be used to derive some macros on the generated enums data.
/// If the attribute is not used, the macros Debug, PartialEq and Eq are derived by default.
/// 
/// ```rust
/// use strunemix::*;
/// 
/// #[derive(Default, Strunemix)]
/// #[strunemix_derive_data(Debug, PartialEq, Eq, Clone)]
/// struct Person {
///   pseudo: String,
///   age: i32,
///   phone: Option<String>
/// }
/// 
/// let age = PersonAttrData::Age(42);
/// let age_clone = age.clone();
/// ```
/// 
/// ## Derive Macros on the enums names and data
/// 
/// This attribute can be used to derive some macros on both the generated enums names and data.
/// If the attribute is not used, the macros derived are the same as the ones derived on the enums names and data.
pub use strunemix_macros::Strunemix;
