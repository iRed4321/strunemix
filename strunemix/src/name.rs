/// Trait implemented automatically on enums names generated by strunemix.
pub trait StrunemixName : Sized + FromStr<Err = StrunemixFromError>
{

    /// Get the name of the enum value as a string slice
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Strunemix)]
    /// struct Person {
    ///    age: i32,
    ///    name: Option<String>,
    /// }
    /// 
    /// let age = PersonAttrName::Age;
    /// 
    /// assert_eq!(age.get_str(), "age");
    /// ```
    fn get_str(&self) -> &'static str {
        panic!("This function should be implemented by the derive macro")
    }

    /// Get an enum value by its name
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Strunemix)]
    /// struct Person {
    ///   age: i32,
    ///   name: Option<String>,
    /// }
    /// 
    /// let age = PersonAttrName::from_str("age").unwrap();
    /// 
    /// assert_eq!(age, PersonAttrName::Age);
    fn from_str(name: &str) -> Result<Self, StrunemixFromError> {
        <Self as std::str::FromStr>::from_str(name)
    }

}

use std::str::FromStr;

use crate::{error::StrunemixParseError, StrunemixFromError};
#[cfg(doc)]
use crate::StrunemixForm;

/// Trait that allow the conversion from a string slice to each of the inner types of an enum of datas.
/// 
/// Implement it on a [StrunemixName] generated enum to allow the use of [add_data][StrunemixParsableData] on it.\
/// It also enables the use of [`StrunemixForm::set_data_str`] on a [StrunemixForm] to set data from a string slice.
/// 
/// # Example
/// 
/// ```rust
/// use strunemix::*;
/// 
/// #[derive(Strunemix)]
/// #[strunemix_derive_data(Debug, PartialEq)]
/// struct Person {
///    age: i32,
///    name: Option<String>,
/// }
/// 
/// impl StrunemixParsableData<'_, PersonAttrData> for PersonAttrName {
///   fn add_data(&self, data: &str) -> Result<PersonAttrData, StrunemixParseError> {
///     match &self {
///       PersonAttrName::Name => Ok(PersonAttrData::Name(Some(data.to_string()))),
///       PersonAttrName::Age => Ok(PersonAttrData::Age(data.parse()?))
///     }
///   }
/// }
/// ```
pub trait StrunemixParsableData<'a, U> 
where 
    Self: StrunemixName
{
    /// Add data from string to an enum of name;
    /// 
    /// ```rust
    /// use strunemix::*;
    /// 
    /// #[derive(Strunemix)]
    /// #[strunemix_derive_data(Debug, PartialEq)]
    /// pub struct Person {
    ///    name: String,
    ///    age: i32,
    /// }
    /// 
    /// // {Implementation of StrunemixParsableData}
    /// 
    /// let name = PersonAttrName::Name;
    /// let name_data = name.add_data("John").unwrap();
    /// # impl StrunemixParsableData<'_, PersonAttrData> for PersonAttrName {
    /// #   fn add_data(&self, data: &str) -> Result<PersonAttrData, StrunemixParseError> {
    /// #     match &self {
    /// #       PersonAttrName::Name => Ok(PersonAttrData::Name(data.to_string())),
    /// #       PersonAttrName::Age => Ok(PersonAttrData::Age(data.parse()?))
    /// #     }
    /// #   }
    /// # }
    /// assert_eq!(name_data, PersonAttrData::Name("John".to_string()));
    /// ```
    fn add_data(&self, data: &'a str) -> Result<U, StrunemixParseError>;
}